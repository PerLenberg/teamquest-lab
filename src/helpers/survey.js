import { db } from '../services/firebase';

//Misc functions for accessing survey related data (e.g. meta-data or responses)
//(very tuned to how we use Firebase)

//General survey data loader
export const load = async (surveyId) => {
    let surveyObject = null;
    
    //Fetch entire survey node (meta-data and responses)
    try {
      const snapshot = await db.ref(`surveys/${surveyId}`).once("value");
      if (!snapshot.hasChild('meta/teamId'))
        throw new Error(`No meta-data found for survey ${surveyId}`);
      //Append to id to "raw" object content
      surveyObject = { id : surveyId, ...snapshot.val() };
     } catch (e) {
      const errMsg = "Could not load survey object from database.";
      console.log(errMsg, e);
      throw new Error(errMsg); 
    }
    
    return surveyObject;
};

//Load (and subscribe for) all surveys for a specific team
//Data will be provided to callback function as array with oldest first
//- second argument is an "error" boolean, indicating issues during parsing
//This function returns a "reference" that shall be provided to
//cancelAll to end the subscription (at some point)
export const getAll = (teamId, cb) => {
  let dataRef = null; //default return value
  try {
    if (!cb) //A "better" check would also cover type and signature etc.
      throw new Error("No callback function specified");

    //TODO: check that team (child) exists
    
    const ref = db.ref("surveys").orderByChild("meta/teamId").equalTo(teamId);
    dataRef = ref.on("value", snapshot => {
      let surveys = [];
      let anyError = false;
      snapshot.forEach(snap => {
        if (snap.hasChild('meta/teamId')) {
          //Append to id to "raw" object content
          surveys.push({ id: snap.key, ...snap.val() });
        } else {
          //don't throw in this callback (who will catch?)
          console.log(`No meta-data found for survey ${snap.key}`);
          anyError = true;
        }
      });

      //Sort by time? No, just rely on Firebase "default" key order
      //From the docs:
      //"The unique key generated by push() is based on a timestamp,
      // so list items are automatically ordered chronologically."
      cb(surveys, anyError);
    })
  } catch (e) {
    const errMsg = "Could not setup subscription for surveys data.";
    console.log(errMsg, e);
    throw new Error(errMsg);
  }

  return dataRef;
};

//Cancel subscription for team data (see getAll above)
export const cancelAll = (teamId, dbDataRef) => {
  try {
    const ref = db.ref("surveys").orderByChild("meta/teamId").equalTo(teamId);
    ref.off("value", dbDataRef);
  } catch(e) {
    const errMsg = "Could not cancel survey data subscription.";
    console.log(errMsg, e);
    throw new Error(errMsg);
  }
};

//General survey questions loader (based on question-set ID found in meta-data)
export const loadQuestions = async (surveyObject) => {
  let questions = [];
  
  try {
    //First get the applicable question-set ID for this survey run
    if (!surveyObject.meta.hasOwnProperty('questionsId'))
      throw new Error("No applicable question-set found.");
    const questionsId = surveyObject.meta.questionsId;

    //Then read the actual questions for this question-set ID
    //Firebase only use "objects", i.e. not "arrays". But there should be one key for
    //each index in the intended array (not very robust parsing here).
    const snapshot = await db.ref(`question-sets/${questionsId}/questions`).orderByKey().once("value");
    const numQuestions = snapshot.numChildren();
    if (!numQuestions)
      throw new Error(`No questions found for question-set id: ${questionsId}.`);
    snapshot.forEach((snap) => {
      questions.push(snap.val());
    });    
  } catch (e) {
    const errMsg = "Could not load questions from database.";
    console.log(errMsg, e);
    throw new Error(errMsg);
  }

  return questions;
}

//Get the offset [ms] between local and server time (according to Firebase)
export const getServerTimeOffset = async () => {
    let sTimeOffset = null;
    
    try {
      const snapshot = await db.ref('/.info/serverTimeOffset').once('value');
      sTimeOffset = snapshot.val();
    } catch (e) {
      const errMsg = "Could not read time offset from database.";
      console.log(errMsg, e);
      throw new Error(errMsg);
    }

    return sTimeOffset;
};

//Store answers by pushing a new response entry to the database      
export const pushResponse = async (surveyId, answers) => {
  try {
    //In the database, answers are store as an string-version of an array. Why?
    // - Firebase doesn't handled arrays (implicit conversion to Objects)
    //   -> not possible to defined access rules based on "length"
    // - This is a workaround that is based on the fact that we know:
    //   - fixed number of 1-digit numbers (allows for "simple" firebase rule)
    //   - we must "array:ify" the response when we later extract it anyway
    // TODO (?): obscure the insertion order to prevent fixed relation between
    //           answers and answer-time order
    const answersStr = JSON.stringify(answers);
    await db.ref(`surveys/${surveyId}/responses`).transaction(prev => 
      (prev ? `${prev},` : " ") + answersStr);
  } catch(e) {
    const errMsg = "Could not write response to database.";
    console.log(errMsg, e);
    throw new Error(errMsg);
  }
}

//Check how much time [ms] is left before the survey closes
export const getTimeLeft = (surveyObject, sTimeOffset = 0) => {
    let timeLeft = 0;
    
    try {
      const meta = surveyObject.meta;
      //First check if it has been closed/terminated "manually"
      if (meta.hoursOpen) {
        //Compare current time with survey config
        const closingTime = (meta.hoursOpen * 3600000) + meta.createTime;
        const now = (new Date()).getTime() + sTimeOffset;
        timeLeft = closingTime - now;
        //console.log("getTimeLeft: closingTime:",closingTime, "now:",now, "timeLeft:", timeLeft);
        timeLeft = (timeLeft < 0) ? 0 : timeLeft; //don't keep track of how long ago it closed
      }
    } catch (e) {
      const errMsg = "Could not derive time left for survey.";
      console.log(errMsg, e);
      throw new Error(errMsg);
    }

    return timeLeft;
};

//Parse the responses string into an array of arrays (of numbers)
//(this is the result of the decision to "simplify" the access rule/validation logic in Firebase)
export const getResponses = (surveyObject) => {
  const meta = surveyObject.meta;
  const lenPerRsp = meta.lenIncrement;
  const maxLen = meta.maxLenAnswers;
  const minLen = meta.minLenAnswers;
  
  if (!(lenPerRsp && maxLen && minLen))
    throw new Error("Survey meta-data missing min/max settings.");
  
  //Don't bother to check too much in advance. Try parsing and do one
  //final check of the end result
  try {
    const ansPerRsp = (lenPerRsp - 2) / 2; //two characters per answer + 2
    const min = minLen / lenPerRsp;
    const max = maxLen / lenPerRsp;

    //no responses is a valid (initial) case
    let responses = [];
    if (surveyObject.responses) {
      responses = JSON.parse("[" + surveyObject.responses + "]");
      const allOK = (responses.length <= maxLen) &&
        responses.reduce((rOK, r) => (
          rOK && r.length === ansPerRsp &&
          r.reduce((aOK, a) => (
            aOK && Number.isInteger(a) && a >= 0 && a <=4
          ),true)
        ), true);
      
      if (!allOK) {
        const errMsg = "Failed to parse/validate responses."; 
        console.log(errMsg, responses);
        throw new Error(errMsg);
      }
    }
    return {responses, min, max};
  } catch(e) {
    const errMsg = "Survey meta-data for min/max settings corrupted.";
    console.log(errMsg, e);
    throw new Error(errMsg);
  }
}

//Is the survey still open (can we post new answers?).
//Two variants;
//- <no-suffix> (will analyze an existing object structure, i.e. already fetched data) 
//- "ById" ("async" variant; will fetch fresh data from Firebase)
export const isOpen = (surveyObject) => {
  try {
    const timeLeft = getTimeLeft(surveyObject);
    const respHandle = getResponses(surveyObject);

    return (timeLeft > 0) && 
      (respHandle.responses.length < respHandle.max);
  } catch(e) {
    const errMsg = "Could not determine open-status for survey.";
    console.log(errMsg, e);
    throw new Error(errMsg);
  }
}

export const isOpenById = async (surveyId) => {
  try {
    const surveyObject = await load(surveyId);
    return isOpen(surveyObject);
  } catch(e) {
    const errMsg = `Could not determine open-status for survey id ${surveyId}.`;
    console.log(errMsg, e);
    throw new Error(errMsg);
  }
}

//Helper for determining the completion level of a survey based on responses etc.
export const CompLev = {
  CANCELED: 'canceled',
  TOO_FEW : 'too few responders',
  SOME    : 'enough responders',
  ALL     : 'all responders'  
};
export const getCompLev = (surveyObj, respHandle = null) => {
  let level = CompLev.CANCELED;  
  
  try {
    if (!respHandle) {
      respHandle = getResponses(surveyObj);
    }

    if (surveyObj.meta.hoursOpen) {
      if (respHandle.responses.length < respHandle.min) {
        level = CompLev.TOO_FEW;
      } else if (respHandle.responses.length === respHandle.max) {
        level = CompLev.ALL;
      } else {
        level = CompLev.SOME;
      }
    } else {
      //Explicitly cancelled
      level = CompLev.CANCELED;
    }
  } catch(e) {
    const errMsg = `Could not determine completion level`;
    console.log(errMsg, e);
    //TBD: better to throw here?
    //throw new Error(errMsg);
    level = CompLev.CANCELED;
  }
  return level;
}

//Derive (/refine) meta-status for a survey object
//NOTE: returns an object { meta, respHandle }
export const getMeta = (surveyObj, respHandle = null) => {
  try {
    if (!respHandle) {
      respHandle = getResponses(surveyObj);
    }
    
    //Collect the "meta status"
    const meta = {
      id: surveyObj.id,
      createTime: surveyObj.meta.createTime,
      compLev: getCompLev(surveyObj, respHandle),
      ongoing: isOpen(surveyObj),
      numResponders: respHandle.responses.length
    }

    return { meta, respHandle };

  } catch (e) {
    const errMsg = `Could not derive survey meta data`;
    console.log(errMsg, e);
    throw new Error(errMsg);    
  }
}